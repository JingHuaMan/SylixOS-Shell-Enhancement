19:21 2009-7-8

--SylixOS--

BOOT:

一个裸机可执行程序的运行有两种方法: 

1. 将程序代码入口放在处理器复位向量地址处. 处理器上电可直接运行.

2. 使用装载程序(例如 bootloader )将程序装载到指定的运行地址, 然后将 CPU 控制权交给需要运行的程序.

SylixOS 支持以上两种任意一种的启动方法.

第一种方法最大的优点是: 启动速度快. 系统上电后, 操作系统立即就开始初始化并运行, 不存在任何的多余环节. 几乎所有的单片机系统都是用这种启动方法. 

但是这种启动方法也有他的不足之处: 灵活性不够, 代码执行速度慢, 系统稍有改动, 就需要重新将可执行代码固化(烧写)到复位向量的位置. 

第二种方法启动速度稍慢, 但是灵活性相对较强. bootloader 在启动前可以做些基础性部件的初始化, 同时可以根据配置以不同顺序启动操作系统.

SylixOS 推荐使用第二种方法启动 SylixOS, 虽然 SylixOS 经过裁剪后可以作为 bootloader, 但是为了移植的通用性和兼容性, 还是推荐使用 u-boot 这一类的标准 bootloader.

SylixOS 自己作为 bootloader:

此时可以生成两个 SylixOS 可执行镜像, 一个用来做 bootloader 使用第一种方法启动(经过裁剪后功能相对简单). 然后再从存储介质或通信媒质获取另一个

SylixOS 系统可执行代码镜像, 然后把系统镜像拷贝到需要运行的地址处, 将 CPU 控制权交给需要系统镜像, 完成 boot 过程.

----------------------------------------------------------------------------------------------------------------------
IMAGE

一个程序的执行镜像大致可以分为 3 个区域: text data bss. SylixOS 系统本身同样也是一个执行镜像, 编译链接后也分为这 3 个区域.

1: text      文字池段, 一般由代码, 表格常量组成(包括 C++ 相关的表与体系结构相关的只读段). (运行时不可修改)

2: data      数据段, 需要初始化的全局变量. (在 C 代码运行前需要赋初值)

3: bss       清零段, 需要清零的全局数据区. (在 C 代码运行前需要清零)

链接完成的程序运行时, 可分为两种情况: 

1. text 段紧邻 data.

2. text 段与 data 段没有相邻.

在第一种情况时. 因为 text 与 data 连续, 所以, 在程序装入内存的同时(将二进制文件拷贝入指定地址内存). 已经完成了 data 段的初值初始化.

程序直接运行就可以了(程序只需将 BSS 段清零即可), 如下所示:

+------------+--------------------------------
|    text    |
+------------+           *.bin (文件包含部分)
|    data    |
+------------+--------------------------------
|    bss     |
+------------+ 

当系统运行时 tty 收到 Ctrl+X 指令时, 需要重启系统. 操作系统做完必要的卸载指令后, 程序将从头开始运行, 但是这是 data 段并没有完成重新的初始化.

所以导致运行结果异常. 这时需要使用装载程序重新装入程序即可 (bootloader) 重新 boot.

这种情况切忌不可直接将 PC 指针指向 text 段入口!

一般只有程序是被装载入 RAM 运行时, 为了减少对 RAM 的使用, 运行镜像会使用 text 与 data 段紧邻的方法链接.

第二种情况, text 与 data 不连续, 这种运行的情况一般是程序在 ROM 中运行, 数据段和 BSS 段在 RAM 中. 如下所示:

+------------+--------------------------------
|    text    |
|    table   |           *.bin (文件包含部分)
+------------+--------------------------------

+------------+
|    data    |
+------------+
|    bss     |
+------------+ 

这种情况下, 因为 text 与 data 段不连续, 装载一个 bin 文件不可能完成对 data 段的初始化. 

这时在 text 段中将会出现一个 table, 这个表保存的就是 data 段的初值. 所以需要在程序启动时将 table 内的数据拷贝入

data 段, 完成对 data 段的初始化. bss 段的初始化与上相同. 然后程序就可以正确运行了.

我们通常将保存代码或数据初值备份的区域(并非真实运行区域)叫做->装载域, 例如本例的 table.

将真实程序执行的地址空间称为->运行域.

在本例下, 操作系统做完必要的卸载指令后, 只需将 PC 转移到 text 段入口就可以完成程序的重启, 因为在代码执行初期, 会自动将

table 的值搬运到 data 段中(生成 bin 文件时, 一般由相关工具自动产生此代码).

以上仅是入门级说明, 如果需了解更多请查询 GCC 连接脚本相关文章. 请着重阅读 LMA (装载地址) 和 VMA (运行地址)

----------------------------------------------------------------------------------------------------------------------
BIN vs ELF

一般系统可执行文件分为两类, 纯程序运行代码和带有格式的镜像文件, 这两类文件的代表本别是 bin 和 elf

BIN 文件:

bin 文件仅包含连续的数据, 他可以是代码, 也可以是数据, 一般运行 bin 文件时, 都需要预先直到代码运行的入口地址,

然后将 bin 文件拷贝(或烧录)到该地址以后的存储区. 如果 .text 与 .data 相连, 拷贝 bin 的过程也相当于为 data 做了初始化

如上面所示, 

当然自启动程序(BOOT 的第一种方法) .text 与 .data 不相连. 只需将 bin 烧入 ROM. 上电启动后, bin 内部的程序将自行初始化

.data 段, 这就是程序为什么每次从起始地址运行, C 环境都正确的原因.


ELF 文件:

elf 文件与 bin 文件完全不同, elf 并不是单纯的无格式数据文件, elf 是一种较复杂的程序文件, 分为多种类型, 这里所说的是个执行文件.

elf 文件内部包含有对程序运行信息的描述, 数据的存放, 调试信息等等.

elf 内部程序代码一般不包含有对 .data 段初始化的代码, 所以切记, 仅仅拷贝 elf 内部的代码, 是不能正确运行程序的!

elf 内部一般由多分段组成, 每个分段都有物理地址(装载域)和虚拟地址(运行域), 

注意: 这里的物理地址与虚拟地址和操作系统 MMU 管理是截然不同的概念.

当 .text 与 .data 连续时, 一般分段物理地址与虚拟地址相同, 所以只要根据文件信息将相关的数据拷贝入指定的内存即可.

当 .text 与 .data 不连续时, 有些段的物理地址与虚拟地址将不再相同, 这时注意, 需要将文件数据拷贝入物理地址(装载域)指定的内存中

程序启动时会自动将物理地址(装载域)内的相关数据, 拷贝入虚拟地址(运行域). 这样完成对某些段(例如:.data)的初始化.

所以切记: 当 .text 与 .data 连续的可执行文件, 是不能轻易重启的, 必须由 bootloader 从新装载完成重启(推荐).

----------------------------------------------------------------------------------------------------------------------

在生成 bootloader 时, (即使用一个 sylixos 启动另一个系统), 推荐不要开启 MMU 和 DCACHE, 因为如果启动镜像小, 建立 MMU 页表的时间

反而远远超过装载镜像的时间.
