21:53 2009-7-17

--SylixOS--

使用 select() 功能:

一个设备要支持 select() 系统调用, 驱动程序的 ioctl 入口一定要提供 FIOSELECT 和 FIOUNSELECT 这两个命令,

可以参考管道设备源码.

这里要指出: sylixos 标准设备, 如: tty, pty, pipe, spipe, stream 均提供 select() 接口.

应用程序需要注意的是: 这些设备当发生某种事件时的激活顺序, 以 tty 设备举例, 当 tty 设备可读时, 内部将

先激活 read() 端阻塞, 再立即激活 select() 端阻塞. 系统提供的其他设备具有相同的顺序.

---------------------------------------------------------------------------------------------------------

例如: 

方式一:
    select(...);
    if (FD_ISSET(...)) {
        read(...); or write(...);
    } else {
        timeout...
    }
   
    这是经典的操作方式, 此方式不会有任何问题.

方式一:

    read(...);
    select(...);   /* read block */

    这种方式可能会出问题, 假设用户使用 pty 设备读取数据, 当 read() 操作时可能因为无数据而被阻塞. 当 pty
 
    内部有数据可读时, pty 将会首先激活 read() 操作. 当用户任务优先级较高时(SylixOS 是抢占式实时调度), 

    read() 操作会立即被激活, 用户程序将会立即运行, 此时 pty 内部还没有完成激活 select() 的操作, 这时当用户

    read() 操作完毕后将会调用 select(), select() 检测到无数据可读时, 将会继续阻塞, 这是系统又会轮到 pty 执行

    此时 pty 将会继续调用激活 select() 的操作(刚刚被抢占了). 这时, 用户的 select() 操作被立即激活, 这是一次虚假

    的激活, 因为没有数据可读.

    以上代码运行序列, 如下图: ("---->" 表示系统接下来要运行的任务)

     ------------------------------  |  -----------------------------
                pty                              user
      
                ...                            read(...)
                                   <----
              ... (recv a char)

              wakeup read.
                                   ---->       
                                               select(...)
                                   <----
              wakeup select       
                                   ---->
                                               这里被激活了, 但是没有数据可读.


